Details of the Algorithm

For the first project I am tasked with coding a solver to the 3n+1 problem found here, http://www.spoj.pl/problems/PROBTNPO/. Although it hasn't been proved, the theory is that if you take any whole number greater than 1 and look at whether it's even or odd, apply two rules, it will eventually return to 1. If it's even, divide the number by two and start again. If it's odd, multiply it by 3 and add 1 and then start again. The algorithm to do this is quite simple, but speeding it up will add a small challenge.

The simplest way to solve this is to start with a **while** loop that is conditional on the number you start with. If the number is greater than 1, continue with the algorithm, else stop. The number will be changed within the loop and then rechecked once the loop reaches the bottom.

Now Sphere is not asking for just the cycle length (how many numbers it takes to get to 1) of one number, but asking for the largest cycle length within a range of starting numbers. So the actual answer will require a **for** loop from the first number in the range to the last number. The 3n+1 solver will run inside this **for** loop and a variable will be needed to keep track of the current largest cycle length . When the **for** loop is finished the variable will contain the largest cycle length for that range and can print it out in the manner Sphere wants.

The above implementation will work but it won't be fast. Chances are that the range of values share common numbers in the cycle length. To capitalize on this, we can make an array of any size (under 1 million since we're guaranteed not to have a number above it) and either pre-populate it with the cycle length for each number (e.g 1 is 1, 3 is 8, 5 is 6) or fill it up when the number is encountered during solving.  At this point in time, I don't know which of the two is faster. For longer tests pre-populating seems like it would be faster, and for short tests it would be a waste to pre-compute thousands of unused lengths.

Creating an Aggressive Cache (one that precomputes) turns out to be slower than a Naive cache. I attribute this to wasting time precomputing values that will not be used. The size of the test input also matters. If the program were to continuously run for minutes, constantly bombarded with ranges then it would be advantages to have all values precomputed.

For V2 of the 3n+1 problem, I am convinced that Sphere is expecting wrong answers. Running my program on the 64bit CS machines, I get no overflow issues using a 64bit long. To account for machine differences, I changed my unsigned long to uint64\_t but uint64\_t caused Sphere to give a wrong answer, while the unsigned long implementation was accepted. The problem says I can assume that no operation overflows a 32 bit int but this is obviously wrong. I believe that by saying this, it leads the programmer to believe that a 32-bit container is the minimum size required when it is actually the maximum. The same problem occurred for Java also (longs are 64 bits always). The fix was to and 4294967295L with the 3n+1 result. This would simulate an overflow if an answer grew above that amount. Once that was added, the Java program worked.

My actual implementation creates a static array of 1000001 longs. Once a range is received, the eval function uses an iterative approach to compute each number's cycle length. The cycle\_length starts at 1. If the number in the range is 1, then the program skips over the 3n+1 algorithm and saves the cycle length of 1. Otherwise, the number is moved to a temp variable (64 bit long to account for overflow). If that number is under 1000000, then the temp variable is used to reference into the saved cycle length array. If a non-zero value is found then the algorithm is done for that number and it instantly reports its length. Otherwise, if the number is over 1000000 or if there is a zero value in the array, the cycle length must be manually computed. If the number is odd, the temp variable is multiplied by 3, incremented by one, and then divided by 2. The cycle length is incremented by 2 at this point. If the number was even, then the number is divided by 2 and only 1 is added to the cycle length. Once the temp variable reaches 1, the loop ends and the cycle length for the original number is saved in the static array. One issue with the static array is that some starting numbers cause the temp variable to go above 1000000. This is why there is a check in the algorithm. Another variable keeps track of the max cycle\_length and returns it to the caller once all number in the range have finished.